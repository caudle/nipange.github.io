// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'filter_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FilterEventTearOff {
  const _$FilterEventTearOff();

  _Started started() {
    return const _Started();
  }

  _ClearAll clearAll() {
    return const _ClearAll();
  }

  _TypeChanged typeChanged(String type) {
    return _TypeChanged(
      type,
    );
  }

  _PriceChanged priceChanged(List<String> prices) {
    return _PriceChanged(
      prices,
    );
  }

  _SizeChanged sizeChanged(List<String> sizes) {
    return _SizeChanged(
      sizes,
    );
  }

  _BathChanged bathChanged(String bath) {
    return _BathChanged(
      bath,
    );
  }

  _BedChanged bedChanged(String bed) {
    return _BedChanged(
      bed,
    );
  }

  _TermsChanged termsChanged(String terms) {
    return _TermsChanged(
      terms,
    );
  }

  _AmenitiesChanged amenitiesChanged(List<String> amenitys) {
    return _AmenitiesChanged(
      amenitys,
    );
  }

  _Send send() {
    return const _Send();
  }
}

/// @nodoc
const $FilterEvent = _$FilterEventTearOff();

/// @nodoc
mixin _$FilterEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FilterEventCopyWith<$Res> {
  factory $FilterEventCopyWith(
          FilterEvent value, $Res Function(FilterEvent) then) =
      _$FilterEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$FilterEventCopyWithImpl<$Res> implements $FilterEventCopyWith<$Res> {
  _$FilterEventCopyWithImpl(this._value, this._then);

  final FilterEvent _value;
  // ignore: unused_field
  final $Res Function(FilterEvent) _then;
}

/// @nodoc
abstract class _$StartedCopyWith<$Res> {
  factory _$StartedCopyWith(_Started value, $Res Function(_Started) then) =
      __$StartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$StartedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$StartedCopyWith<$Res> {
  __$StartedCopyWithImpl(_Started _value, $Res Function(_Started) _then)
      : super(_value, (v) => _then(v as _Started));

  @override
  _Started get _value => super._value as _Started;
}

/// @nodoc
class _$_Started with DiagnosticableTreeMixin implements _Started {
  const _$_Started();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.started()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'FilterEvent.started'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Started);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements FilterEvent {
  const factory _Started() = _$_Started;
}

/// @nodoc
abstract class _$ClearAllCopyWith<$Res> {
  factory _$ClearAllCopyWith(_ClearAll value, $Res Function(_ClearAll) then) =
      __$ClearAllCopyWithImpl<$Res>;
}

/// @nodoc
class __$ClearAllCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$ClearAllCopyWith<$Res> {
  __$ClearAllCopyWithImpl(_ClearAll _value, $Res Function(_ClearAll) _then)
      : super(_value, (v) => _then(v as _ClearAll));

  @override
  _ClearAll get _value => super._value as _ClearAll;
}

/// @nodoc
class _$_ClearAll with DiagnosticableTreeMixin implements _ClearAll {
  const _$_ClearAll();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.clearAll()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'FilterEvent.clearAll'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ClearAll);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return clearAll();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (clearAll != null) {
      return clearAll();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return clearAll(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (clearAll != null) {
      return clearAll(this);
    }
    return orElse();
  }
}

abstract class _ClearAll implements FilterEvent {
  const factory _ClearAll() = _$_ClearAll;
}

/// @nodoc
abstract class _$TypeChangedCopyWith<$Res> {
  factory _$TypeChangedCopyWith(
          _TypeChanged value, $Res Function(_TypeChanged) then) =
      __$TypeChangedCopyWithImpl<$Res>;
  $Res call({String type});
}

/// @nodoc
class __$TypeChangedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$TypeChangedCopyWith<$Res> {
  __$TypeChangedCopyWithImpl(
      _TypeChanged _value, $Res Function(_TypeChanged) _then)
      : super(_value, (v) => _then(v as _TypeChanged));

  @override
  _TypeChanged get _value => super._value as _TypeChanged;

  @override
  $Res call({
    Object? type = freezed,
  }) {
    return _then(_TypeChanged(
      type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$_TypeChanged with DiagnosticableTreeMixin implements _TypeChanged {
  const _$_TypeChanged(this.type);

  @override
  final String type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.typeChanged(type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.typeChanged'))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TypeChanged &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(type);

  @JsonKey(ignore: true)
  @override
  _$TypeChangedCopyWith<_TypeChanged> get copyWith =>
      __$TypeChangedCopyWithImpl<_TypeChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return typeChanged(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (typeChanged != null) {
      return typeChanged(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return typeChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (typeChanged != null) {
      return typeChanged(this);
    }
    return orElse();
  }
}

abstract class _TypeChanged implements FilterEvent {
  const factory _TypeChanged(String type) = _$_TypeChanged;

  String get type => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$TypeChangedCopyWith<_TypeChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PriceChangedCopyWith<$Res> {
  factory _$PriceChangedCopyWith(
          _PriceChanged value, $Res Function(_PriceChanged) then) =
      __$PriceChangedCopyWithImpl<$Res>;
  $Res call({List<String> prices});
}

/// @nodoc
class __$PriceChangedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$PriceChangedCopyWith<$Res> {
  __$PriceChangedCopyWithImpl(
      _PriceChanged _value, $Res Function(_PriceChanged) _then)
      : super(_value, (v) => _then(v as _PriceChanged));

  @override
  _PriceChanged get _value => super._value as _PriceChanged;

  @override
  $Res call({
    Object? prices = freezed,
  }) {
    return _then(_PriceChanged(
      prices == freezed
          ? _value.prices
          : prices // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
class _$_PriceChanged with DiagnosticableTreeMixin implements _PriceChanged {
  const _$_PriceChanged(this.prices);

  @override
  final List<String> prices;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.priceChanged(prices: $prices)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.priceChanged'))
      ..add(DiagnosticsProperty('prices', prices));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PriceChanged &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(prices);

  @JsonKey(ignore: true)
  @override
  _$PriceChangedCopyWith<_PriceChanged> get copyWith =>
      __$PriceChangedCopyWithImpl<_PriceChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return priceChanged(prices);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (priceChanged != null) {
      return priceChanged(prices);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return priceChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (priceChanged != null) {
      return priceChanged(this);
    }
    return orElse();
  }
}

abstract class _PriceChanged implements FilterEvent {
  const factory _PriceChanged(List<String> prices) = _$_PriceChanged;

  List<String> get prices => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$PriceChangedCopyWith<_PriceChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SizeChangedCopyWith<$Res> {
  factory _$SizeChangedCopyWith(
          _SizeChanged value, $Res Function(_SizeChanged) then) =
      __$SizeChangedCopyWithImpl<$Res>;
  $Res call({List<String> sizes});
}

/// @nodoc
class __$SizeChangedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$SizeChangedCopyWith<$Res> {
  __$SizeChangedCopyWithImpl(
      _SizeChanged _value, $Res Function(_SizeChanged) _then)
      : super(_value, (v) => _then(v as _SizeChanged));

  @override
  _SizeChanged get _value => super._value as _SizeChanged;

  @override
  $Res call({
    Object? sizes = freezed,
  }) {
    return _then(_SizeChanged(
      sizes == freezed
          ? _value.sizes
          : sizes // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
class _$_SizeChanged with DiagnosticableTreeMixin implements _SizeChanged {
  const _$_SizeChanged(this.sizes);

  @override
  final List<String> sizes;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.sizeChanged(sizes: $sizes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.sizeChanged'))
      ..add(DiagnosticsProperty('sizes', sizes));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SizeChanged &&
            (identical(other.sizes, sizes) ||
                const DeepCollectionEquality().equals(other.sizes, sizes)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(sizes);

  @JsonKey(ignore: true)
  @override
  _$SizeChangedCopyWith<_SizeChanged> get copyWith =>
      __$SizeChangedCopyWithImpl<_SizeChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return sizeChanged(sizes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (sizeChanged != null) {
      return sizeChanged(sizes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return sizeChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (sizeChanged != null) {
      return sizeChanged(this);
    }
    return orElse();
  }
}

abstract class _SizeChanged implements FilterEvent {
  const factory _SizeChanged(List<String> sizes) = _$_SizeChanged;

  List<String> get sizes => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$SizeChangedCopyWith<_SizeChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$BathChangedCopyWith<$Res> {
  factory _$BathChangedCopyWith(
          _BathChanged value, $Res Function(_BathChanged) then) =
      __$BathChangedCopyWithImpl<$Res>;
  $Res call({String bath});
}

/// @nodoc
class __$BathChangedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$BathChangedCopyWith<$Res> {
  __$BathChangedCopyWithImpl(
      _BathChanged _value, $Res Function(_BathChanged) _then)
      : super(_value, (v) => _then(v as _BathChanged));

  @override
  _BathChanged get _value => super._value as _BathChanged;

  @override
  $Res call({
    Object? bath = freezed,
  }) {
    return _then(_BathChanged(
      bath == freezed
          ? _value.bath
          : bath // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$_BathChanged with DiagnosticableTreeMixin implements _BathChanged {
  const _$_BathChanged(this.bath);

  @override
  final String bath;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.bathChanged(bath: $bath)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.bathChanged'))
      ..add(DiagnosticsProperty('bath', bath));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BathChanged &&
            (identical(other.bath, bath) ||
                const DeepCollectionEquality().equals(other.bath, bath)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(bath);

  @JsonKey(ignore: true)
  @override
  _$BathChangedCopyWith<_BathChanged> get copyWith =>
      __$BathChangedCopyWithImpl<_BathChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return bathChanged(bath);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (bathChanged != null) {
      return bathChanged(bath);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return bathChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (bathChanged != null) {
      return bathChanged(this);
    }
    return orElse();
  }
}

abstract class _BathChanged implements FilterEvent {
  const factory _BathChanged(String bath) = _$_BathChanged;

  String get bath => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$BathChangedCopyWith<_BathChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$BedChangedCopyWith<$Res> {
  factory _$BedChangedCopyWith(
          _BedChanged value, $Res Function(_BedChanged) then) =
      __$BedChangedCopyWithImpl<$Res>;
  $Res call({String bed});
}

/// @nodoc
class __$BedChangedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$BedChangedCopyWith<$Res> {
  __$BedChangedCopyWithImpl(
      _BedChanged _value, $Res Function(_BedChanged) _then)
      : super(_value, (v) => _then(v as _BedChanged));

  @override
  _BedChanged get _value => super._value as _BedChanged;

  @override
  $Res call({
    Object? bed = freezed,
  }) {
    return _then(_BedChanged(
      bed == freezed
          ? _value.bed
          : bed // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$_BedChanged with DiagnosticableTreeMixin implements _BedChanged {
  const _$_BedChanged(this.bed);

  @override
  final String bed;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.bedChanged(bed: $bed)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.bedChanged'))
      ..add(DiagnosticsProperty('bed', bed));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BedChanged &&
            (identical(other.bed, bed) ||
                const DeepCollectionEquality().equals(other.bed, bed)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(bed);

  @JsonKey(ignore: true)
  @override
  _$BedChangedCopyWith<_BedChanged> get copyWith =>
      __$BedChangedCopyWithImpl<_BedChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return bedChanged(bed);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (bedChanged != null) {
      return bedChanged(bed);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return bedChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (bedChanged != null) {
      return bedChanged(this);
    }
    return orElse();
  }
}

abstract class _BedChanged implements FilterEvent {
  const factory _BedChanged(String bed) = _$_BedChanged;

  String get bed => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$BedChangedCopyWith<_BedChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$TermsChangedCopyWith<$Res> {
  factory _$TermsChangedCopyWith(
          _TermsChanged value, $Res Function(_TermsChanged) then) =
      __$TermsChangedCopyWithImpl<$Res>;
  $Res call({String terms});
}

/// @nodoc
class __$TermsChangedCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$TermsChangedCopyWith<$Res> {
  __$TermsChangedCopyWithImpl(
      _TermsChanged _value, $Res Function(_TermsChanged) _then)
      : super(_value, (v) => _then(v as _TermsChanged));

  @override
  _TermsChanged get _value => super._value as _TermsChanged;

  @override
  $Res call({
    Object? terms = freezed,
  }) {
    return _then(_TermsChanged(
      terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$_TermsChanged with DiagnosticableTreeMixin implements _TermsChanged {
  const _$_TermsChanged(this.terms);

  @override
  final String terms;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.termsChanged(terms: $terms)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.termsChanged'))
      ..add(DiagnosticsProperty('terms', terms));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TermsChanged &&
            (identical(other.terms, terms) ||
                const DeepCollectionEquality().equals(other.terms, terms)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(terms);

  @JsonKey(ignore: true)
  @override
  _$TermsChangedCopyWith<_TermsChanged> get copyWith =>
      __$TermsChangedCopyWithImpl<_TermsChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return termsChanged(terms);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (termsChanged != null) {
      return termsChanged(terms);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return termsChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (termsChanged != null) {
      return termsChanged(this);
    }
    return orElse();
  }
}

abstract class _TermsChanged implements FilterEvent {
  const factory _TermsChanged(String terms) = _$_TermsChanged;

  String get terms => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$TermsChangedCopyWith<_TermsChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$AmenitiesChangedCopyWith<$Res> {
  factory _$AmenitiesChangedCopyWith(
          _AmenitiesChanged value, $Res Function(_AmenitiesChanged) then) =
      __$AmenitiesChangedCopyWithImpl<$Res>;
  $Res call({List<String> amenitys});
}

/// @nodoc
class __$AmenitiesChangedCopyWithImpl<$Res>
    extends _$FilterEventCopyWithImpl<$Res>
    implements _$AmenitiesChangedCopyWith<$Res> {
  __$AmenitiesChangedCopyWithImpl(
      _AmenitiesChanged _value, $Res Function(_AmenitiesChanged) _then)
      : super(_value, (v) => _then(v as _AmenitiesChanged));

  @override
  _AmenitiesChanged get _value => super._value as _AmenitiesChanged;

  @override
  $Res call({
    Object? amenitys = freezed,
  }) {
    return _then(_AmenitiesChanged(
      amenitys == freezed
          ? _value.amenitys
          : amenitys // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
class _$_AmenitiesChanged
    with DiagnosticableTreeMixin
    implements _AmenitiesChanged {
  const _$_AmenitiesChanged(this.amenitys);

  @override
  final List<String> amenitys;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.amenitiesChanged(amenitys: $amenitys)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterEvent.amenitiesChanged'))
      ..add(DiagnosticsProperty('amenitys', amenitys));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AmenitiesChanged &&
            (identical(other.amenitys, amenitys) ||
                const DeepCollectionEquality()
                    .equals(other.amenitys, amenitys)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(amenitys);

  @JsonKey(ignore: true)
  @override
  _$AmenitiesChangedCopyWith<_AmenitiesChanged> get copyWith =>
      __$AmenitiesChangedCopyWithImpl<_AmenitiesChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return amenitiesChanged(amenitys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (amenitiesChanged != null) {
      return amenitiesChanged(amenitys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return amenitiesChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (amenitiesChanged != null) {
      return amenitiesChanged(this);
    }
    return orElse();
  }
}

abstract class _AmenitiesChanged implements FilterEvent {
  const factory _AmenitiesChanged(List<String> amenitys) = _$_AmenitiesChanged;

  List<String> get amenitys => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AmenitiesChangedCopyWith<_AmenitiesChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SendCopyWith<$Res> {
  factory _$SendCopyWith(_Send value, $Res Function(_Send) then) =
      __$SendCopyWithImpl<$Res>;
}

/// @nodoc
class __$SendCopyWithImpl<$Res> extends _$FilterEventCopyWithImpl<$Res>
    implements _$SendCopyWith<$Res> {
  __$SendCopyWithImpl(_Send _value, $Res Function(_Send) _then)
      : super(_value, (v) => _then(v as _Send));

  @override
  _Send get _value => super._value as _Send;
}

/// @nodoc
class _$_Send with DiagnosticableTreeMixin implements _Send {
  const _$_Send();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterEvent.send()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'FilterEvent.send'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Send);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() clearAll,
    required TResult Function(String type) typeChanged,
    required TResult Function(List<String> prices) priceChanged,
    required TResult Function(List<String> sizes) sizeChanged,
    required TResult Function(String bath) bathChanged,
    required TResult Function(String bed) bedChanged,
    required TResult Function(String terms) termsChanged,
    required TResult Function(List<String> amenitys) amenitiesChanged,
    required TResult Function() send,
  }) {
    return send();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? clearAll,
    TResult Function(String type)? typeChanged,
    TResult Function(List<String> prices)? priceChanged,
    TResult Function(List<String> sizes)? sizeChanged,
    TResult Function(String bath)? bathChanged,
    TResult Function(String bed)? bedChanged,
    TResult Function(String terms)? termsChanged,
    TResult Function(List<String> amenitys)? amenitiesChanged,
    TResult Function()? send,
    required TResult orElse(),
  }) {
    if (send != null) {
      return send();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_ClearAll value) clearAll,
    required TResult Function(_TypeChanged value) typeChanged,
    required TResult Function(_PriceChanged value) priceChanged,
    required TResult Function(_SizeChanged value) sizeChanged,
    required TResult Function(_BathChanged value) bathChanged,
    required TResult Function(_BedChanged value) bedChanged,
    required TResult Function(_TermsChanged value) termsChanged,
    required TResult Function(_AmenitiesChanged value) amenitiesChanged,
    required TResult Function(_Send value) send,
  }) {
    return send(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_ClearAll value)? clearAll,
    TResult Function(_TypeChanged value)? typeChanged,
    TResult Function(_PriceChanged value)? priceChanged,
    TResult Function(_SizeChanged value)? sizeChanged,
    TResult Function(_BathChanged value)? bathChanged,
    TResult Function(_BedChanged value)? bedChanged,
    TResult Function(_TermsChanged value)? termsChanged,
    TResult Function(_AmenitiesChanged value)? amenitiesChanged,
    TResult Function(_Send value)? send,
    required TResult orElse(),
  }) {
    if (send != null) {
      return send(this);
    }
    return orElse();
  }
}

abstract class _Send implements FilterEvent {
  const factory _Send() = _$_Send;
}

/// @nodoc
class _$FilterStateTearOff {
  const _$FilterStateTearOff();

  _FilterState call(
      {required Future<List<String>>? futureTypes,
      required String type,
      required Future<List<String>>? futurePriceRange,
      required List<String> priceRange,
      required Future<List<String>>? futureSizeRange,
      required List<String> sizeRange,
      required Future<List<String>>? futureBedroom,
      required String bedroom,
      required Future<List<String>>? futureBathroom,
      required String bathroom,
      required Future<List<String>>? futureTerms,
      required String terms,
      required Future<List<String>>? futureAmenities,
      required List<String> amenities,
      required bool isLoading,
      required bool isSuccess,
      required bool isError,
      required Future<List<Listing>> listings}) {
    return _FilterState(
      futureTypes: futureTypes,
      type: type,
      futurePriceRange: futurePriceRange,
      priceRange: priceRange,
      futureSizeRange: futureSizeRange,
      sizeRange: sizeRange,
      futureBedroom: futureBedroom,
      bedroom: bedroom,
      futureBathroom: futureBathroom,
      bathroom: bathroom,
      futureTerms: futureTerms,
      terms: terms,
      futureAmenities: futureAmenities,
      amenities: amenities,
      isLoading: isLoading,
      isSuccess: isSuccess,
      isError: isError,
      listings: listings,
    );
  }
}

/// @nodoc
const $FilterState = _$FilterStateTearOff();

/// @nodoc
mixin _$FilterState {
  Future<List<String>>? get futureTypes => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  Future<List<String>>? get futurePriceRange =>
      throw _privateConstructorUsedError;
  List<String> get priceRange => throw _privateConstructorUsedError;
  Future<List<String>>? get futureSizeRange =>
      throw _privateConstructorUsedError;
  List<String> get sizeRange => throw _privateConstructorUsedError;
  Future<List<String>>? get futureBedroom => throw _privateConstructorUsedError;
  String get bedroom => throw _privateConstructorUsedError;
  Future<List<String>>? get futureBathroom =>
      throw _privateConstructorUsedError;
  String get bathroom => throw _privateConstructorUsedError;
  Future<List<String>>? get futureTerms => throw _privateConstructorUsedError;
  String get terms => throw _privateConstructorUsedError;
  Future<List<String>>? get futureAmenities =>
      throw _privateConstructorUsedError;
  List<String> get amenities => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  bool get isSuccess => throw _privateConstructorUsedError;
  bool get isError => throw _privateConstructorUsedError;
  Future<List<Listing>> get listings => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FilterStateCopyWith<FilterState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FilterStateCopyWith<$Res> {
  factory $FilterStateCopyWith(
          FilterState value, $Res Function(FilterState) then) =
      _$FilterStateCopyWithImpl<$Res>;
  $Res call(
      {Future<List<String>>? futureTypes,
      String type,
      Future<List<String>>? futurePriceRange,
      List<String> priceRange,
      Future<List<String>>? futureSizeRange,
      List<String> sizeRange,
      Future<List<String>>? futureBedroom,
      String bedroom,
      Future<List<String>>? futureBathroom,
      String bathroom,
      Future<List<String>>? futureTerms,
      String terms,
      Future<List<String>>? futureAmenities,
      List<String> amenities,
      bool isLoading,
      bool isSuccess,
      bool isError,
      Future<List<Listing>> listings});
}

/// @nodoc
class _$FilterStateCopyWithImpl<$Res> implements $FilterStateCopyWith<$Res> {
  _$FilterStateCopyWithImpl(this._value, this._then);

  final FilterState _value;
  // ignore: unused_field
  final $Res Function(FilterState) _then;

  @override
  $Res call({
    Object? futureTypes = freezed,
    Object? type = freezed,
    Object? futurePriceRange = freezed,
    Object? priceRange = freezed,
    Object? futureSizeRange = freezed,
    Object? sizeRange = freezed,
    Object? futureBedroom = freezed,
    Object? bedroom = freezed,
    Object? futureBathroom = freezed,
    Object? bathroom = freezed,
    Object? futureTerms = freezed,
    Object? terms = freezed,
    Object? futureAmenities = freezed,
    Object? amenities = freezed,
    Object? isLoading = freezed,
    Object? isSuccess = freezed,
    Object? isError = freezed,
    Object? listings = freezed,
  }) {
    return _then(_value.copyWith(
      futureTypes: futureTypes == freezed
          ? _value.futureTypes
          : futureTypes // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      futurePriceRange: futurePriceRange == freezed
          ? _value.futurePriceRange
          : futurePriceRange // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      priceRange: priceRange == freezed
          ? _value.priceRange
          : priceRange // ignore: cast_nullable_to_non_nullable
              as List<String>,
      futureSizeRange: futureSizeRange == freezed
          ? _value.futureSizeRange
          : futureSizeRange // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      sizeRange: sizeRange == freezed
          ? _value.sizeRange
          : sizeRange // ignore: cast_nullable_to_non_nullable
              as List<String>,
      futureBedroom: futureBedroom == freezed
          ? _value.futureBedroom
          : futureBedroom // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      bedroom: bedroom == freezed
          ? _value.bedroom
          : bedroom // ignore: cast_nullable_to_non_nullable
              as String,
      futureBathroom: futureBathroom == freezed
          ? _value.futureBathroom
          : futureBathroom // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      bathroom: bathroom == freezed
          ? _value.bathroom
          : bathroom // ignore: cast_nullable_to_non_nullable
              as String,
      futureTerms: futureTerms == freezed
          ? _value.futureTerms
          : futureTerms // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      terms: terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as String,
      futureAmenities: futureAmenities == freezed
          ? _value.futureAmenities
          : futureAmenities // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      amenities: amenities == freezed
          ? _value.amenities
          : amenities // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isSuccess: isSuccess == freezed
          ? _value.isSuccess
          : isSuccess // ignore: cast_nullable_to_non_nullable
              as bool,
      isError: isError == freezed
          ? _value.isError
          : isError // ignore: cast_nullable_to_non_nullable
              as bool,
      listings: listings == freezed
          ? _value.listings
          : listings // ignore: cast_nullable_to_non_nullable
              as Future<List<Listing>>,
    ));
  }
}

/// @nodoc
abstract class _$FilterStateCopyWith<$Res>
    implements $FilterStateCopyWith<$Res> {
  factory _$FilterStateCopyWith(
          _FilterState value, $Res Function(_FilterState) then) =
      __$FilterStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Future<List<String>>? futureTypes,
      String type,
      Future<List<String>>? futurePriceRange,
      List<String> priceRange,
      Future<List<String>>? futureSizeRange,
      List<String> sizeRange,
      Future<List<String>>? futureBedroom,
      String bedroom,
      Future<List<String>>? futureBathroom,
      String bathroom,
      Future<List<String>>? futureTerms,
      String terms,
      Future<List<String>>? futureAmenities,
      List<String> amenities,
      bool isLoading,
      bool isSuccess,
      bool isError,
      Future<List<Listing>> listings});
}

/// @nodoc
class __$FilterStateCopyWithImpl<$Res> extends _$FilterStateCopyWithImpl<$Res>
    implements _$FilterStateCopyWith<$Res> {
  __$FilterStateCopyWithImpl(
      _FilterState _value, $Res Function(_FilterState) _then)
      : super(_value, (v) => _then(v as _FilterState));

  @override
  _FilterState get _value => super._value as _FilterState;

  @override
  $Res call({
    Object? futureTypes = freezed,
    Object? type = freezed,
    Object? futurePriceRange = freezed,
    Object? priceRange = freezed,
    Object? futureSizeRange = freezed,
    Object? sizeRange = freezed,
    Object? futureBedroom = freezed,
    Object? bedroom = freezed,
    Object? futureBathroom = freezed,
    Object? bathroom = freezed,
    Object? futureTerms = freezed,
    Object? terms = freezed,
    Object? futureAmenities = freezed,
    Object? amenities = freezed,
    Object? isLoading = freezed,
    Object? isSuccess = freezed,
    Object? isError = freezed,
    Object? listings = freezed,
  }) {
    return _then(_FilterState(
      futureTypes: futureTypes == freezed
          ? _value.futureTypes
          : futureTypes // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      futurePriceRange: futurePriceRange == freezed
          ? _value.futurePriceRange
          : futurePriceRange // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      priceRange: priceRange == freezed
          ? _value.priceRange
          : priceRange // ignore: cast_nullable_to_non_nullable
              as List<String>,
      futureSizeRange: futureSizeRange == freezed
          ? _value.futureSizeRange
          : futureSizeRange // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      sizeRange: sizeRange == freezed
          ? _value.sizeRange
          : sizeRange // ignore: cast_nullable_to_non_nullable
              as List<String>,
      futureBedroom: futureBedroom == freezed
          ? _value.futureBedroom
          : futureBedroom // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      bedroom: bedroom == freezed
          ? _value.bedroom
          : bedroom // ignore: cast_nullable_to_non_nullable
              as String,
      futureBathroom: futureBathroom == freezed
          ? _value.futureBathroom
          : futureBathroom // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      bathroom: bathroom == freezed
          ? _value.bathroom
          : bathroom // ignore: cast_nullable_to_non_nullable
              as String,
      futureTerms: futureTerms == freezed
          ? _value.futureTerms
          : futureTerms // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      terms: terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as String,
      futureAmenities: futureAmenities == freezed
          ? _value.futureAmenities
          : futureAmenities // ignore: cast_nullable_to_non_nullable
              as Future<List<String>>?,
      amenities: amenities == freezed
          ? _value.amenities
          : amenities // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isSuccess: isSuccess == freezed
          ? _value.isSuccess
          : isSuccess // ignore: cast_nullable_to_non_nullable
              as bool,
      isError: isError == freezed
          ? _value.isError
          : isError // ignore: cast_nullable_to_non_nullable
              as bool,
      listings: listings == freezed
          ? _value.listings
          : listings // ignore: cast_nullable_to_non_nullable
              as Future<List<Listing>>,
    ));
  }
}

/// @nodoc
class _$_FilterState with DiagnosticableTreeMixin implements _FilterState {
  const _$_FilterState(
      {required this.futureTypes,
      required this.type,
      required this.futurePriceRange,
      required this.priceRange,
      required this.futureSizeRange,
      required this.sizeRange,
      required this.futureBedroom,
      required this.bedroom,
      required this.futureBathroom,
      required this.bathroom,
      required this.futureTerms,
      required this.terms,
      required this.futureAmenities,
      required this.amenities,
      required this.isLoading,
      required this.isSuccess,
      required this.isError,
      required this.listings});

  @override
  final Future<List<String>>? futureTypes;
  @override
  final String type;
  @override
  final Future<List<String>>? futurePriceRange;
  @override
  final List<String> priceRange;
  @override
  final Future<List<String>>? futureSizeRange;
  @override
  final List<String> sizeRange;
  @override
  final Future<List<String>>? futureBedroom;
  @override
  final String bedroom;
  @override
  final Future<List<String>>? futureBathroom;
  @override
  final String bathroom;
  @override
  final Future<List<String>>? futureTerms;
  @override
  final String terms;
  @override
  final Future<List<String>>? futureAmenities;
  @override
  final List<String> amenities;
  @override
  final bool isLoading;
  @override
  final bool isSuccess;
  @override
  final bool isError;
  @override
  final Future<List<Listing>> listings;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterState(futureTypes: $futureTypes, type: $type, futurePriceRange: $futurePriceRange, priceRange: $priceRange, futureSizeRange: $futureSizeRange, sizeRange: $sizeRange, futureBedroom: $futureBedroom, bedroom: $bedroom, futureBathroom: $futureBathroom, bathroom: $bathroom, futureTerms: $futureTerms, terms: $terms, futureAmenities: $futureAmenities, amenities: $amenities, isLoading: $isLoading, isSuccess: $isSuccess, isError: $isError, listings: $listings)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FilterState'))
      ..add(DiagnosticsProperty('futureTypes', futureTypes))
      ..add(DiagnosticsProperty('type', type))
      ..add(DiagnosticsProperty('futurePriceRange', futurePriceRange))
      ..add(DiagnosticsProperty('priceRange', priceRange))
      ..add(DiagnosticsProperty('futureSizeRange', futureSizeRange))
      ..add(DiagnosticsProperty('sizeRange', sizeRange))
      ..add(DiagnosticsProperty('futureBedroom', futureBedroom))
      ..add(DiagnosticsProperty('bedroom', bedroom))
      ..add(DiagnosticsProperty('futureBathroom', futureBathroom))
      ..add(DiagnosticsProperty('bathroom', bathroom))
      ..add(DiagnosticsProperty('futureTerms', futureTerms))
      ..add(DiagnosticsProperty('terms', terms))
      ..add(DiagnosticsProperty('futureAmenities', futureAmenities))
      ..add(DiagnosticsProperty('amenities', amenities))
      ..add(DiagnosticsProperty('isLoading', isLoading))
      ..add(DiagnosticsProperty('isSuccess', isSuccess))
      ..add(DiagnosticsProperty('isError', isError))
      ..add(DiagnosticsProperty('listings', listings));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _FilterState &&
            (identical(other.futureTypes, futureTypes) ||
                const DeepCollectionEquality()
                    .equals(other.futureTypes, futureTypes)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.futurePriceRange, futurePriceRange) ||
                const DeepCollectionEquality()
                    .equals(other.futurePriceRange, futurePriceRange)) &&
            (identical(other.priceRange, priceRange) ||
                const DeepCollectionEquality()
                    .equals(other.priceRange, priceRange)) &&
            (identical(other.futureSizeRange, futureSizeRange) ||
                const DeepCollectionEquality()
                    .equals(other.futureSizeRange, futureSizeRange)) &&
            (identical(other.sizeRange, sizeRange) ||
                const DeepCollectionEquality()
                    .equals(other.sizeRange, sizeRange)) &&
            (identical(other.futureBedroom, futureBedroom) ||
                const DeepCollectionEquality()
                    .equals(other.futureBedroom, futureBedroom)) &&
            (identical(other.bedroom, bedroom) ||
                const DeepCollectionEquality()
                    .equals(other.bedroom, bedroom)) &&
            (identical(other.futureBathroom, futureBathroom) ||
                const DeepCollectionEquality()
                    .equals(other.futureBathroom, futureBathroom)) &&
            (identical(other.bathroom, bathroom) ||
                const DeepCollectionEquality()
                    .equals(other.bathroom, bathroom)) &&
            (identical(other.futureTerms, futureTerms) ||
                const DeepCollectionEquality()
                    .equals(other.futureTerms, futureTerms)) &&
            (identical(other.terms, terms) ||
                const DeepCollectionEquality().equals(other.terms, terms)) &&
            (identical(other.futureAmenities, futureAmenities) ||
                const DeepCollectionEquality()
                    .equals(other.futureAmenities, futureAmenities)) &&
            (identical(other.amenities, amenities) ||
                const DeepCollectionEquality()
                    .equals(other.amenities, amenities)) &&
            (identical(other.isLoading, isLoading) ||
                const DeepCollectionEquality()
                    .equals(other.isLoading, isLoading)) &&
            (identical(other.isSuccess, isSuccess) ||
                const DeepCollectionEquality()
                    .equals(other.isSuccess, isSuccess)) &&
            (identical(other.isError, isError) ||
                const DeepCollectionEquality()
                    .equals(other.isError, isError)) &&
            (identical(other.listings, listings) ||
                const DeepCollectionEquality()
                    .equals(other.listings, listings)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(futureTypes) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(futurePriceRange) ^
      const DeepCollectionEquality().hash(priceRange) ^
      const DeepCollectionEquality().hash(futureSizeRange) ^
      const DeepCollectionEquality().hash(sizeRange) ^
      const DeepCollectionEquality().hash(futureBedroom) ^
      const DeepCollectionEquality().hash(bedroom) ^
      const DeepCollectionEquality().hash(futureBathroom) ^
      const DeepCollectionEquality().hash(bathroom) ^
      const DeepCollectionEquality().hash(futureTerms) ^
      const DeepCollectionEquality().hash(terms) ^
      const DeepCollectionEquality().hash(futureAmenities) ^
      const DeepCollectionEquality().hash(amenities) ^
      const DeepCollectionEquality().hash(isLoading) ^
      const DeepCollectionEquality().hash(isSuccess) ^
      const DeepCollectionEquality().hash(isError) ^
      const DeepCollectionEquality().hash(listings);

  @JsonKey(ignore: true)
  @override
  _$FilterStateCopyWith<_FilterState> get copyWith =>
      __$FilterStateCopyWithImpl<_FilterState>(this, _$identity);
}

abstract class _FilterState implements FilterState {
  const factory _FilterState(
      {required Future<List<String>>? futureTypes,
      required String type,
      required Future<List<String>>? futurePriceRange,
      required List<String> priceRange,
      required Future<List<String>>? futureSizeRange,
      required List<String> sizeRange,
      required Future<List<String>>? futureBedroom,
      required String bedroom,
      required Future<List<String>>? futureBathroom,
      required String bathroom,
      required Future<List<String>>? futureTerms,
      required String terms,
      required Future<List<String>>? futureAmenities,
      required List<String> amenities,
      required bool isLoading,
      required bool isSuccess,
      required bool isError,
      required Future<List<Listing>> listings}) = _$_FilterState;

  @override
  Future<List<String>>? get futureTypes => throw _privateConstructorUsedError;
  @override
  String get type => throw _privateConstructorUsedError;
  @override
  Future<List<String>>? get futurePriceRange =>
      throw _privateConstructorUsedError;
  @override
  List<String> get priceRange => throw _privateConstructorUsedError;
  @override
  Future<List<String>>? get futureSizeRange =>
      throw _privateConstructorUsedError;
  @override
  List<String> get sizeRange => throw _privateConstructorUsedError;
  @override
  Future<List<String>>? get futureBedroom => throw _privateConstructorUsedError;
  @override
  String get bedroom => throw _privateConstructorUsedError;
  @override
  Future<List<String>>? get futureBathroom =>
      throw _privateConstructorUsedError;
  @override
  String get bathroom => throw _privateConstructorUsedError;
  @override
  Future<List<String>>? get futureTerms => throw _privateConstructorUsedError;
  @override
  String get terms => throw _privateConstructorUsedError;
  @override
  Future<List<String>>? get futureAmenities =>
      throw _privateConstructorUsedError;
  @override
  List<String> get amenities => throw _privateConstructorUsedError;
  @override
  bool get isLoading => throw _privateConstructorUsedError;
  @override
  bool get isSuccess => throw _privateConstructorUsedError;
  @override
  bool get isError => throw _privateConstructorUsedError;
  @override
  Future<List<Listing>> get listings => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$FilterStateCopyWith<_FilterState> get copyWith =>
      throw _privateConstructorUsedError;
}
